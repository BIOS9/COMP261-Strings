Brute force algorithm takes O(mn) time where m is the length of the data and n is the length of the pattern
KMP takes O(m + n) where m is the length of the data and n is the n is the length of the pattern. m time is taken to search the string, n time is taken to generate the pattern table

in KMP the index in the data never moves backwards.

lps
0 1 2 3 4 5 6 7 8 9  10 11 12
a b c d x a b d y a  b  c  a
0 0 0 0 0 1 2 0 0 1  2  3  1

put position + 1 in the lps table, which is the point to start the next comparison from because it can skip position
When character is mismatched, the prefix index jumps to the position notated in the previous slot, not 0.

To build lps table:

```
let i = 1
let j = 0

let pattern = string to search for
let table = array with length of pattern string, initialized to empty or 0

initialize first slot in table to 0 if not already done

while (i < length of table)
    if (pattern[i] equals pattern[j])
        table[i] = j + 1
        i = i + 1
        j = j + 1
    else
        if (j equals 0)
            table[i] = 0;
            i = i + 1
        else
            j = table[j - 1]
        end if
    end if
end while
```

to search using the table

```
let data = data string in which to search for pattern

let i = 0 // Index in the data to search, never goes backwards
let j = 0 // Index in the pattern to search for

let pattern = string to search for
let table = pattern prefix table

while (i < (length of data - length of pattern) + 1)
    if (data[i] equals pattern[j])
        i = i + 1
        j = j + 1

        if (j equals length of pattern)
            match found at i - j
            either return result here,
            or j = table[j - 1] // j cannot return to start in case pattern can occur intersecting with itself e.g pattern "aaa" might
        end if
    else
        if (j equals 0)
            i = i + 1
        else
            j = table[j - 1]
        end if
    end if
end while

return no match if not already returned
```


Performance results:
BRUTE FORCE:
Time taken for Brute Force: 2722 ms for 6105 TINY patterns | 0.45 ms per pattern.
Time taken for Brute Force: 8044 ms for 17196 SMALL patterns | 0.47 ms per pattern.
Time taken for Brute Force: 5336 ms for 11306 MEDIUM patterns | 0.47 ms per pattern.
Time taken for Brute Force: 8261 ms for 17263 LARGE patterns | 0.48 ms per pattern.
Time taken for Brute Force: 1 ms for 3 HUGE patterns | 0.33 ms per pattern.
Total time taken for Brute Force was 24.36 seconds.

KMP:
Time taken for KMP: 2005 ms for 6103 TINY patterns | 0.33 ms per pattern.
Time taken for KMP: 6451 ms for 17205 SMALL patterns | 0.37 ms per pattern.
Time taken for KMP: 3984 ms for 11304 MEDIUM patterns | 0.35 ms per pattern.
Time taken for KMP: 7564 ms for 17272 LARGE patterns | 0.44 ms per pattern.
Time taken for KMP: 2 ms for 3 HUGE patterns | 0.67 ms per pattern.
Total time taken for KMP was 20.01 seconds.

I played around with different test data and found that when all of the patterns were a valid match in the text, or did not exist at all, the brute force algorithm was faster.
The brute force algorithm was also faster on smaller patterns for smaller text due to the overhead of setting up KMP.
KMP became faster when I added shuffled data in to the patterns to search for.

For most small uses of string search I do not think KMP is worth the trouble. It will usually end up slower and it is harder to implement.
And it turns out that the Java implementation of String::indexOf doesn't use KMP or any "fast" algorithm to do its job, it just uses the brute force approach.