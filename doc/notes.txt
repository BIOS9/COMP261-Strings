Brute force algorithm takes O(mn) time where m is the length of the data and n is the length of the pattern
KMP takes O(m + n) where m is the length of the data and n is the n is the length of the pattern. m time is taken to search the string, n time is taken to generate the pattern table

in KMP the index in the data never moves backwards.

lps
0 1 2 3 4 5 6 7 8 9  10 11 12
a b c d x a b d y a  b  c  a
0 0 0 0 0 1 2 0 0 1  2  3  1

put position + 1 in the lps table, which is the point to start the next comparison from because it can skip position
When character is mismatched, the prefix index jumps to the position notated in the previous slot, not 0.

To build lps table:

```
let i = 1
let j = 0

let pattern = string to search for
let table = array with length of pattern string, initialized to empty or 0

initialize first slot in table to 0 if not already done

while (i < length of table)
    if (pattern[i] equals pattern[j])
        table[i] = j + 1
        i = i + 1
        j = j + 1
    else
        if (j equals 0)
            table[i] = 0;
            i = i + 1
        else
            j = table[j - 1]
        end if
    end if
end while
```

to search using the table

```
let data = data string in which to search for pattern

let i = 0 // Index in the data to search, never goes backwards
let j = 0 // Index in the pattern to search for

let pattern = string to search for
let table = pattern prefix table

while (i < (length of data - length of pattern) + 1)
    if (data[i] equals pattern[j])
        i = i + 1
        j = j + 1

        if (j equals length of pattern)
            match found at i - j
            either return result here,
            or j = table[j - 1] // j cannot return to start in case pattern can occur intersecting with itself e.g pattern "aaa" might
        end if
    else
        if (j equals 0)
            i = i + 1
        else
            j = table[j - 1]
        end if
    end if
end while

return no match if not already returned
```


Performance results:
BRUTE FORCE:
Time taken for Brute Force: 2722 ms for 6105 TINY patterns | 0.45 ms per pattern.
Time taken for Brute Force: 8044 ms for 17196 SMALL patterns | 0.47 ms per pattern.
Time taken for Brute Force: 5336 ms for 11306 MEDIUM patterns | 0.47 ms per pattern.
Time taken for Brute Force: 8261 ms for 17263 LARGE patterns | 0.48 ms per pattern.
Time taken for Brute Force: 1 ms for 3 HUGE patterns | 0.33 ms per pattern.
Total time taken for Brute Force was 24.36 seconds.

KMP:
Time taken for KMP: 2005 ms for 6103 TINY patterns | 0.33 ms per pattern.
Time taken for KMP: 6451 ms for 17205 SMALL patterns | 0.37 ms per pattern.
Time taken for KMP: 3984 ms for 11304 MEDIUM patterns | 0.35 ms per pattern.
Time taken for KMP: 7564 ms for 17272 LARGE patterns | 0.44 ms per pattern.
Time taken for KMP: 2 ms for 3 HUGE patterns | 0.67 ms per pattern.
Total time taken for KMP was 20.01 seconds.

I played around with different test data and found that when all of the patterns were a valid match in the text, or did not exist at all, the brute force algorithm was faster.
The brute force algorithm was also faster on smaller patterns for smaller text due to the overhead of setting up KMP.
KMP became faster when I added shuffled data in to the patterns to search for.

For most small uses of string search I do not think KMP is worth the trouble. It will usually end up slower and it is harder to implement.
And it turns out that the Java implementation of String::indexOf doesn't use KMP or any "fast" algorithm to do its job, it just uses the brute force approach.

Huffman results:
War and peace:
input length:  3258246 bytes
output length: 1848598 bytes
original and decoded texts match.
Compression ratio: 1.76

Taisho:
input length:  3649944 bytes
output length: 1542656 bytes
original and decoded texts match.
Compression ratio: 2.36

Pi:
input length:  1010003 bytes
output length: 443632 bytes
original and decoded texts match.
Compression ratio: 2.27


LZ77:
Can use []| to delimit tuples in text as they do not occur
every tuple has a character to put on the end
[offset, length, next symbol]
e.g [0,0,j] for if first character was j

Outputs a string of the mentioned tuples
Moves through the text one character at a time
Drags a sliding windows behind the cursor
Expands a lookahead buffer from the cursor/The string it tries to match in the sliding window

Pseudocode:
```
let cursor = 0
let windowSize = 100

while (cursor < text.length - 1)
    look for longest prefix of text[cursor .. text.length - 1] in text[max(cursor-windowSize, 0) .. cursor - 1] // max is used to select either from start of text (0) or start of window

    if found, add [offset, length, text[cursor+length]] to output
    else add [0, 0, text[cursor]] to output
    end if

    advance cursor by length + 1
end while
```

Probably just use brute force java indexOf to find match

More pseudocode:

```
let cursor = 0
let windowSize = 100

while (cursor < text.length - 1)
    let length = 0
    let prevMatch = 0

    loop
        let match = stringMatch(text[cursor.. cursor+length],
            text[(cursor<windowSize)?0:cursor-windowSize .. cursor - 1])

        if match succeeded then:
            prevMatch = match
            length = length + 1
        else
            output ([a value for prevMatch, length, text[cursor+length]])
            cursor = cursor + length + 1
            break
        end if
    end loop
end while
```